{"version":3,"file":"definitions.js","sourceRoot":"","sources":["../../src/definitions.ts"],"names":[],"mappings":"","sourcesContent":["import type { PluginListenerHandle } from '@capacitor/core';\n\n// Payload from a new NFC scan is a base64 encoded string\nexport type PayloadType = string | number[] | Uint8Array;\n\nexport interface StartScanOptions {\n  /**\n   * Select the native reader strategy.\n   * - `auto` (default): attempt advanced tag session first, downgrade automatically on entitlement failures.\n   * - `full`: force the advanced tag session (resets any cached fallback state).\n   * - `compat`: force the compatibility tag session (ISO14443-only, avoids advanced entitlements).\n   * - `ndef`: skip tag session entirely and use the legacy NDEF reader.\n   */\n  mode?: 'auto' | 'full' | 'compat' | 'ndef';\n  /**\n   * Backwards-compatible hints for older app code. When true, they map to `mode` selections above.\n   */\n  forceFull?: boolean;\n  forceCompat?: boolean;\n  forceNDEF?: boolean;\n}\n\nexport interface NFCPluginBasic {\n  /**\n   * Checks if NFC is supported on the device. Returns true on all iOS devices, and checks for support on Android.\n   */\n  isSupported(): Promise<{ supported: boolean }>;\n\n  /**\n   * Begins listening for NFC tags.\n   * @param options Optional tuning parameters for native reader behavior.\n   */\n  startScan(options?: StartScanOptions): Promise<void>;\n\n  /**\n   * Cancels an ongoing scan session (iOS only currently; no-op / rejection on Android).\n   */\n  cancelScan(): Promise<void>;\n\n  /**\n   * Writes an NDEF message to an NFC tag.\n   * @param options The NDEF message to write.\n   */\n  writeNDEF<T extends PayloadType = number[]>(options: NDEFWriteOptions<T>): Promise<void>;\n\n  /**\n   * Cancels writeNDEF on Android (exits \"write mode\").\n   */\n  cancelWriteAndroid(): Promise<void>;\n\n  /**\n   * Adds a listener for NFC tag detection events.\n   * @param eventName The name of the event ('nfcTag').\n   * @param listenerFunc The function to call when an NFC tag is detected.\n   */\n  addListener(\n    eventName: 'nfcTag',\n    listenerFunc: (data: NDEFMessages) => void,\n  ): Promise<PluginListenerHandle> & PluginListenerHandle;\n\n  /**\n   * Adds a listener for NFC tag write events.\n   * @param eventName The name of the event ('nfcWriteSuccess').\n   * @param listenerFunc The function to call when an NFC tag is written.\n   */\n  addListener(\n    eventName: 'nfcWriteSuccess',\n    listenerFunc: () => void,\n  ): Promise<PluginListenerHandle> & PluginListenerHandle;\n\n  /**\n   * Adds a listener for NFC error events.\n   * @param eventName The name of the event ('nfcError').\n   * @param listenerFunc The function to call when an NFC error occurs.\n   */\n  addListener(\n    eventName: 'nfcError',\n    listenerFunc: (error: NFCError) => void,\n  ): Promise<PluginListenerHandle> & PluginListenerHandle;\n\n  /**\n   * Removes all listeners for the specified event.\n   * @param eventName The name of the event.\n   */\n  removeAllListeners(eventName: 'nfcTag' | 'nfcError'): Promise<void>;\n}\n\nexport interface NDEFMessages<T extends PayloadType = string> {\n  messages: NDEFMessage<T>[];\n  tagInfo?: TagInfo;\n}\n\nexport interface NDEFMessage<T extends PayloadType = string> {\n  records: NDEFRecord<T>[];\n}\n\nexport interface TagInfo {\n  /**\n   * The unique identifier of the tag (UID) as a hex string\n   */\n  uid?: string;\n\n  /**\n   * The NFC tag technology types supported\n   */\n  techTypes?: string[];\n\n  /**\n   * The maximum size of NDEF message that can be written to this tag (if applicable)\n   */\n  maxSize?: number;\n\n  /**\n   * Whether the tag is writable\n   */\n  isWritable?: boolean;\n\n  /**\n   * The tag type (e.g., \"ISO14443-4\", \"MifareClassic\", etc.)\n   */\n  type?: string;\n\n  /**\n   * Truthy when the plugin downgraded reader capabilities for compatibility.\n   */\n  fallback?: boolean;\n\n  /**\n   * Indicates the active fallback mode (`compat` or `ndef`).\n   */\n  fallbackMode?: 'compat' | 'ndef';\n\n  /**\n   * Optional reason string when fallback was applied (e.g., `missing-entitlement`).\n   */\n  reason?: string;\n}\n\nexport interface NDEFRecord<T extends PayloadType = string> {\n  /**\n   * The type of the record.\n   */\n  type: string;\n\n  /**\n   * The payload of the record.\n   */\n  payload: T;\n}\n\nexport interface NFCError {\n  /**\n   * The error message.\n   */\n  error: string;\n}\n\nexport interface NDEFWriteOptions<T extends PayloadType = Uint8Array> {\n  records: NDEFRecord<T>[];\n  /**\n   * When true, bypasses automatic Well Known Type formatting (Text 'T' and URI 'U' prefixes).\n   * All payloads are written as raw bytes without additional framing.\n   */\n  rawMode?: boolean;\n}\n\nexport type NDEFMessagesTransformable = {\n  base64: () => NDEFMessages;\n  uint8Array: () => NDEFMessages<Uint8Array>;\n  string: () => NDEFMessages;\n  numberArray: () => NDEFMessages<number[]>;\n};\n\nexport type TagResultListenerFunc = (data: NDEFMessagesTransformable) => void;\n\nexport interface NFCPlugin extends Omit<NFCPluginBasic, 'writeNDEF' | 'addListener'> {\n  writeNDEF: <T extends PayloadType = Uint8Array>(record?: NDEFWriteOptions<T>) => Promise<void>;\n  wrapperListeners: TagResultListenerFunc[];\n  /**\n   * Register a read listener. Returns an unsubscribe function to remove just this listener.\n   */\n  onRead: (listenerFunc: TagResultListenerFunc) => () => void;\n  /**\n   * Register a write success listener. Returns an unsubscribe function.\n   */\n  onWrite: (listenerFunc: () => void) => () => void;\n  /**\n   * Register an error listener. Returns an unsubscribe function.\n   */\n  onError: (listenerFunc: (error: NFCError) => void) => () => void;\n}\n"]}